{
  "version": 3,
  "sources": ["../../../lambda/src/handlers/pdf-check.ts", "../../../lambda/src/services/parasut.ts", "../../../lambda/src/utils/whatsapp.ts"],
  "sourcesContent": ["/**\n * PDF Check Lambda Handler\n * Scheduled to run every 2 minutes\n * Checks pending e-archive PDFs and sends to users when ready\n */\n\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { DynamoDBDocumentClient, ScanCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';\nimport { createParasutService } from '../services/parasut.js';\nimport { sendInvoiceNotification } from '../utils/whatsapp.js';\n\n// DynamoDB client\nconst dynamoClient = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(dynamoClient);\nconst TABLE_NAME = process.env.CONVERSATIONS_TABLE || 'turkish-logistics-conversations';\n\ninterface PendingPdfRecord {\n  pk: string;\n  sk: string;\n  phoneNumber: string;\n  parasutTrackableJobId?: string; // The job ID returned from e-archive creation\n  parasutEArchiveId?: string; // Legacy field, may contain job ID\n  parasutInvoiceId?: string;\n  invoiceStatus: string;\n  createdAt?: string;\n}\n\n/**\n * Check if trackable job is done and get e-archive ID from invoice\n */\nasync function getEArchiveIdFromInvoice(\n  accessToken: string,\n  companyId: string,\n  invoiceId: string\n): Promise<string | null> {\n  try {\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/sales_invoices/${invoiceId}?include=active_e_document`,\n      { headers: { Authorization: `Bearer ${accessToken}` } }\n    );\n\n    if (!response.ok) {\n      console.log(`Failed to get invoice ${invoiceId}: ${response.status}`);\n      return null;\n    }\n\n    const data = await response.json() as {\n      data: {\n        relationships?: {\n          active_e_document?: {\n            data?: { id: string; type: string };\n          };\n        };\n      };\n    };\n\n    const eDocData = data.data.relationships?.active_e_document?.data;\n    if (eDocData?.id) {\n      console.log(`Found e-archive ID ${eDocData.id} for invoice ${invoiceId}`);\n      return eDocData.id;\n    }\n\n    console.log(`No active e-document found for invoice ${invoiceId}`);\n    return null;\n  } catch (error) {\n    console.error(`Error getting e-archive from invoice ${invoiceId}:`, error);\n    return null;\n  }\n}\n\n/**\n * Get PDF URL from e-archive using the e-archive/pdf endpoint\n */\nasync function getPdfUrlFromEArchive(\n  accessToken: string,\n  companyId: string,\n  eArchiveId: string\n): Promise<string | null> {\n  try {\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/e_archives/${eArchiveId}/pdf`,\n      { headers: { Authorization: `Bearer ${accessToken}` } }\n    );\n\n    if (!response.ok) {\n      console.log(`Failed to get PDF for e-archive ${eArchiveId}: ${response.status}`);\n      return null;\n    }\n\n    const data = await response.json() as {\n      data: { attributes: { url?: string } };\n    };\n\n    return data.data.attributes.url || null;\n  } catch (error) {\n    console.error(`Error getting PDF URL for e-archive ${eArchiveId}:`, error);\n    return null;\n  }\n}\n\n/**\n * Check PDF status - handles both job ID and invoice ID\n */\nasync function checkPdfStatus(\n  trackableJobId: string | undefined,\n  invoiceId: string | undefined\n): Promise<string | null> {\n  const parasut = createParasutService();\n  if (!parasut) {\n    console.log('Parasut service not available');\n    return null;\n  }\n\n  if (!invoiceId) {\n    console.log('No invoice ID available');\n    return null;\n  }\n\n  try {\n    const accessToken = await parasut.getAccessToken();\n    const companyId = process.env.PARASUT_COMPANY_ID;\n\n    if (!companyId) {\n      console.log('PARASUT_COMPANY_ID not configured');\n      return null;\n    }\n\n    // If we have a trackable job ID, check if it's done first\n    if (trackableJobId) {\n      const jobResponse = await fetch(\n        `https://api.parasut.com/v4/${companyId}/trackable_jobs/${trackableJobId}`,\n        { headers: { Authorization: `Bearer ${accessToken}` } }\n      );\n\n      if (jobResponse.ok) {\n        const jobData = await jobResponse.json() as {\n          data: { attributes: { status: string } };\n        };\n        const jobStatus = jobData.data.attributes.status;\n        console.log(`Trackable job ${trackableJobId}: status=${jobStatus}`);\n\n        if (jobStatus !== 'done') {\n          console.log('E-archive job still processing');\n          return null;\n        }\n      }\n    }\n\n    // Get the actual e-archive ID from the invoice\n    const eArchiveId = await getEArchiveIdFromInvoice(accessToken, companyId, invoiceId);\n    if (!eArchiveId) {\n      console.log('E-archive not ready yet');\n      return null;\n    }\n\n    // Get the PDF URL\n    const pdfUrl = await getPdfUrlFromEArchive(accessToken, companyId, eArchiveId);\n    if (pdfUrl) {\n      console.log(`Got PDF URL for e-archive ${eArchiveId}`);\n    }\n\n    return pdfUrl;\n  } catch (error) {\n    console.error('Error checking PDF status:', error);\n    return null;\n  }\n}\n\n/**\n * Lambda handler\n */\nexport async function handler(): Promise<{ processed: number; sent: number }> {\n  console.log('Starting PDF check...');\n  console.log(`Using table: ${TABLE_NAME}`);\n\n  // Find all payments with pending_pdf status (with pagination)\n  const pendingRecords: PendingPdfRecord[] = [];\n  let lastEvaluatedKey: Record<string, unknown> | undefined;\n  let totalScanned = 0;\n\n  do {\n    const scanResult = await docClient.send(new ScanCommand({\n      TableName: TABLE_NAME,\n      FilterExpression: 'invoiceStatus = :status',\n      ExpressionAttributeValues: {\n        ':status': 'pending_pdf',\n      },\n      ExclusiveStartKey: lastEvaluatedKey,\n    }));\n\n    totalScanned += scanResult.ScannedCount || 0;\n    pendingRecords.push(...(scanResult.Items || []) as PendingPdfRecord[]);\n    lastEvaluatedKey = scanResult.LastEvaluatedKey as Record<string, unknown> | undefined;\n  } while (lastEvaluatedKey);\n\n  console.log(`Scanned ${totalScanned} items total, found ${pendingRecords.length} pending PDF records`);\n  if (pendingRecords.length > 0) {\n    console.log('Records:', JSON.stringify(pendingRecords.map(r => ({ pk: r.pk, phone: r.phoneNumber }))))\n  }\n\n  let processed = 0;\n  let sent = 0;\n\n  for (const record of pendingRecords) {\n    processed++;\n    const merchantOid = record.pk.replace('PAYMENT#', '');\n\n    // Need either trackable job ID or invoice ID\n    const jobId = record.parasutTrackableJobId || record.parasutEArchiveId; // Legacy fallback\n    if (!record.parasutInvoiceId || !record.phoneNumber) {\n      console.log(`Skipping ${merchantOid}: missing invoiceId or phoneNumber`);\n      continue;\n    }\n\n    // Check if PDF is ready\n    const pdfUrl = await checkPdfStatus(jobId, record.parasutInvoiceId);\n\n    if (pdfUrl) {\n      // Send PDF to user\n      console.log(`Sending PDF to ${record.phoneNumber} for ${merchantOid}`);\n      const messageSent = await sendInvoiceNotification(record.phoneNumber, pdfUrl, merchantOid);\n\n      // Update record with PDF URL and sent status\n      await docClient.send(new UpdateCommand({\n        TableName: TABLE_NAME,\n        Key: { pk: record.pk, sk: record.sk },\n        UpdateExpression: 'SET invoiceStatus = :status, invoicePdfUrl = :pdfUrl, invoiceSentAt = :sentAt, updatedAt = :now',\n        ExpressionAttributeValues: {\n          ':status': messageSent ? 'sent' : 'pdf_ready',\n          ':pdfUrl': pdfUrl,\n          ':sentAt': messageSent ? new Date().toISOString() : null,\n          ':now': new Date().toISOString(),\n        },\n      }));\n\n      if (messageSent) sent++;\n      console.log(`PDF ${messageSent ? 'sent' : 'ready but not sent'} for ${merchantOid}`);\n    } else {\n      // Check if record is too old (> 1 hour)\n      const createdAt = record.createdAt ? new Date(record.createdAt) : new Date();\n      const age = Date.now() - createdAt.getTime();\n      const maxAge = 60 * 60 * 1000; // 1 hour\n\n      if (age > maxAge) {\n        console.log(`Record ${merchantOid} too old (${Math.round(age / 60000)}min), marking as failed`);\n        await docClient.send(new UpdateCommand({\n          TableName: TABLE_NAME,\n          Key: { pk: record.pk, sk: record.sk },\n          UpdateExpression: 'SET invoiceStatus = :status, invoiceError = :error, updatedAt = :now',\n          ExpressionAttributeValues: {\n            ':status': 'pdf_timeout',\n            ':error': 'PDF not available after 1 hour',\n            ':now': new Date().toISOString(),\n          },\n        }));\n      }\n    }\n\n    // Small delay between API calls\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n\n  console.log(`PDF check complete: processed=${processed}, sent=${sent}`);\n  return { processed, sent };\n}\n", "/**\n * Parasut Invoice Service\n * Handles automatic invoice generation from PayTR payments\n */\n\nexport interface ParasutConfig {\n  clientId: string;\n  clientSecret: string;\n  username: string;\n  password: string;\n  companyId: string;\n}\n\nexport interface CompanyData {\n  companyName: string;\n  vkn: string;           // 10-digit VKN (Vergi Kimlik Numarasƒ±)\n  taxOffice: string;\n  address: string;\n  city: string;\n  district: string;\n  email?: string;\n  phone?: string;\n}\n\nexport interface InvoiceData {\n  invoiceType: 'none' | 'company';\n  companyData?: CompanyData;\n}\n\nexport interface InvoiceResult {\n  success: boolean;\n  invoiceId?: string;\n  eArchiveId?: string;\n  pdfUrl?: string;\n  error?: string;\n}\n\nexport class ParasutInvoiceService {\n  private accessToken: string | null = null;\n  private tokenExpiry: number | null = null;\n  private config: ParasutConfig;\n\n  constructor(config: ParasutConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Get or refresh access token\n   */\n  async getAccessToken(): Promise<string> {\n    // Return cached token if still valid (with 5 minute buffer)\n    if (this.accessToken && this.tokenExpiry && this.tokenExpiry > Date.now() + 300000) {\n      return this.accessToken;\n    }\n\n    console.log('Parasut: Authenticating...');\n\n    const response = await fetch('https://api.parasut.com/oauth/token', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        client_id: this.config.clientId,\n        client_secret: this.config.clientSecret,\n        username: this.config.username,\n        password: this.config.password,\n        grant_type: 'password',\n        redirect_uri: 'urn:ietf:wg:oauth:2.0:oob',\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut auth failed:', error);\n      throw new Error('Failed to authenticate with Parasut');\n    }\n\n    const data = await response.json() as { access_token: string; expires_in: number };\n\n    this.accessToken = data.access_token;\n    // Token expires in 7200 seconds (2 hours), subtract 5 minutes for safety\n    this.tokenExpiry = Date.now() + ((data.expires_in - 300) * 1000);\n\n    console.log('Parasut: Authenticated successfully');\n    return this.accessToken;\n  }\n\n  /**\n   * Create or find \"Muhtelif M√º≈üteriler\" contact (for invoices without company data)\n   */\n  async createMinimalContact(accessToken: string): Promise<string> {\n    const { companyId } = this.config;\n\n    // First try to find existing \"Muhtelif M√º≈üteriler\" contact\n    try {\n      const searchResponse = await fetch(\n        `https://api.parasut.com/v4/${companyId}/contacts?filter[name]=Muhtelif%20M%C3%BC%C5%9Fteriler`,\n        {\n          headers: { Authorization: `Bearer ${accessToken}` },\n        }\n      );\n\n      if (searchResponse.ok) {\n        const searchData = await searchResponse.json() as { data?: Array<{ id: string }> };\n        const firstContact = searchData.data?.[0];\n        if (firstContact) {\n          console.log('Parasut: Found existing Muhtelif M√º≈üteriler contact');\n          return firstContact.id;\n        }\n      }\n    } catch {\n      // Ignore search error, try to create\n    }\n\n    // Create new minimal contact\n    const contactData = {\n      data: {\n        type: 'contacts',\n        attributes: {\n          name: 'Muhtelif M√º≈üteriler', // Legal Turkish placeholder\n          contact_type: 'person',\n          account_type: 'customer',\n          tax_number: '11111111111', // Legal placeholder TC number\n          city: 'Istanbul', // Required for e-Archive\n          district: 'Kadikoy', // Required for e-Archive\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/contacts`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(contactData),\n      }\n    );\n\n    if (!response.ok) {\n      // If 422, contact might already exist (duplicate)\n      if (response.status === 422) {\n        console.log('Parasut: Contact already exists, searching...');\n        // Retry search\n        const searchResponse = await fetch(\n          `https://api.parasut.com/v4/${companyId}/contacts?filter[name]=Muhtelif`,\n          { headers: { Authorization: `Bearer ${accessToken}` } }\n        );\n        if (searchResponse.ok) {\n          const searchData = await searchResponse.json() as { data?: Array<{ id: string }> };\n          const foundContact = searchData.data?.[0];\n          if (foundContact) {\n            return foundContact.id;\n          }\n        }\n      }\n      const error = await response.text();\n      console.error('Parasut create minimal contact error:', error);\n      throw new Error('Failed to create minimal contact');\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: Created Muhtelif M√º≈üteriler contact:', data.data.id);\n    return data.data.id;\n  }\n\n  /**\n   * Create or find company contact\n   */\n  async createCompanyContact(accessToken: string, companyData: CompanyData): Promise<string> {\n    const { companyId } = this.config;\n\n    // First try to find by VKN\n    try {\n      const searchResponse = await fetch(\n        `https://api.parasut.com/v4/${companyId}/contacts?filter[tax_number]=${companyData.vkn}`,\n        { headers: { Authorization: `Bearer ${accessToken}` } }\n      );\n\n      if (searchResponse.ok) {\n        const searchData = await searchResponse.json() as { data?: Array<{ id: string }> };\n        const existingContact = searchData.data?.[0];\n        if (existingContact) {\n          console.log('Parasut: Found existing company contact by VKN');\n          return existingContact.id;\n        }\n      }\n    } catch {\n      // Ignore search error, try to create\n    }\n\n    // Create new company contact\n    const contactPayload = {\n      data: {\n        type: 'contacts',\n        attributes: {\n          name: companyData.companyName,\n          contact_type: 'company',\n          account_type: 'customer',\n          tax_office: companyData.taxOffice,\n          tax_number: companyData.vkn,\n          address: companyData.address,\n          city: companyData.city,\n          district: companyData.district,\n          email: companyData.email || undefined,\n          phone: companyData.phone || undefined,\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/contacts`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(contactPayload),\n      }\n    );\n\n    if (!response.ok) {\n      // If 422, contact might already exist\n      if (response.status === 422) {\n        const searchResponse = await fetch(\n          `https://api.parasut.com/v4/${companyId}/contacts?filter[tax_number]=${companyData.vkn}`,\n          { headers: { Authorization: `Bearer ${accessToken}` } }\n        );\n        if (searchResponse.ok) {\n          const searchData = await searchResponse.json() as { data?: Array<{ id: string }> };\n          const foundCompany = searchData.data?.[0];\n          if (foundCompany) {\n            return foundCompany.id;\n          }\n        }\n      }\n      const error = await response.text();\n      console.error('Parasut create company contact error:', error);\n      throw new Error('Failed to create company contact');\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: Created company contact:', data.data.id);\n    return data.data.id;\n  }\n\n  /**\n   * Create or find the Premium Membership product\n   */\n  async getOrCreateProduct(accessToken: string): Promise<string> {\n    const { companyId } = this.config;\n    const productName = 'Patron Premium √úyelik (1 Ay)';\n\n    // First try to find existing product\n    try {\n      const searchResponse = await fetch(\n        `https://api.parasut.com/v4/${companyId}/products?filter[name]=${encodeURIComponent(productName)}`,\n        {\n          headers: { Authorization: `Bearer ${accessToken}` },\n        }\n      );\n\n      if (searchResponse.ok) {\n        const searchData = await searchResponse.json() as { data?: Array<{ id: string }> };\n        const foundProduct = searchData.data?.[0];\n        if (foundProduct) {\n          console.log('Parasut: Found existing product:', foundProduct.id);\n          return foundProduct.id;\n        }\n      }\n    } catch (e) {\n      console.log('Parasut: Product search failed, will create new');\n    }\n\n    // Create new product\n    const productPayload = {\n      data: {\n        type: 'products',\n        attributes: {\n          name: productName,\n          vat_rate: 20,\n          unit: 'Adet',\n          sales_price: 1000, // Net price before VAT\n          currency: 'TRL',\n          product_type: 'service',\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/products`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(productPayload),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut create product error:', error);\n      throw new Error('Failed to create product');\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: Created product:', data.data.id);\n    return data.data.id;\n  }\n\n  /**\n   * Create sales invoice\n   */\n  async createSalesInvoice(\n    accessToken: string,\n    contactId: string,\n    amount: number,\n    merchantOid: string\n  ): Promise<string> {\n    const { companyId } = this.config;\n\n    // Get or create the product first\n    const productId = await this.getOrCreateProduct(accessToken);\n\n    // Calculate net amount (excluding VAT)\n    // Amount is 1200 TL including 20% VAT, so net = 1200 / 1.20 = 1000\n    const netAmount = amount / 1.20;\n\n    const invoicePayload = {\n      data: {\n        type: 'sales_invoices',\n        attributes: {\n          item_type: 'invoice',\n          description: `Patron Premium √úyelik - Sipari≈ü #${merchantOid}`,\n          issue_date: new Date().toISOString().split('T')[0],\n          due_date: new Date().toISOString().split('T')[0],\n          currency: 'TRL',\n          city: 'Istanbul', // Required for e-Archive\n          district: 'Kadikoy', // Required for e-Archive\n        },\n        relationships: {\n          contact: {\n            data: { type: 'contacts', id: contactId },\n          },\n          details: {\n            data: [\n              {\n                type: 'sales_invoice_details',\n                attributes: {\n                  quantity: 1,\n                  unit_price: netAmount,\n                  vat_rate: 20,\n                },\n                relationships: {\n                  product: {\n                    data: { type: 'products', id: productId },\n                  },\n                },\n              },\n            ],\n          },\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/sales_invoices`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(invoicePayload),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut create invoice error:', error);\n      throw new Error('Failed to create invoice');\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: Created invoice:', data.data.id);\n    return data.data.id;\n  }\n\n  /**\n   * Record payment on invoice\n   */\n  async recordPayment(\n    accessToken: string,\n    invoiceId: string,\n    amount: number,\n    merchantOid: string\n  ): Promise<void> {\n    const { companyId } = this.config;\n\n    const paymentPayload = {\n      data: {\n        type: 'payments',\n        attributes: {\n          date: new Date().toISOString().split('T')[0],\n          amount: amount,\n          description: `PayTR √ñdeme - ${merchantOid}`,\n        },\n        relationships: {\n          payable: {\n            data: { type: 'sales_invoices', id: invoiceId },\n          },\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/payments`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(paymentPayload),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut record payment error:', error);\n      // Don't throw - payment recording is not critical\n    } else {\n      console.log('Parasut: Payment recorded');\n    }\n  }\n\n  /**\n   * Generate e-Archive document\n   */\n  async generateEArchive(accessToken: string, invoiceId: string): Promise<string> {\n    const { companyId } = this.config;\n\n    const eArchivePayload = {\n      data: {\n        type: 'e_archives',\n        relationships: {\n          sales_invoice: {\n            data: { type: 'sales_invoices', id: invoiceId },\n          },\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/e_archives`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(eArchivePayload),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut generate e-archive error:', error);\n      throw new Error('Failed to generate e-archive');\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: E-Archive created:', data.data.id);\n    return data.data.id;\n  }\n\n  /**\n   * Get e-Archive PDF URL (with polling for generation completion)\n   */\n  async getEArchivePdfUrl(accessToken: string, eArchiveId: string): Promise<string | null> {\n    const { companyId } = this.config;\n    const maxAttempts = 20;\n    const delayMs = 3000;\n\n    // Poll for PDF URL (generation can take 30-60 seconds)\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      const response = await fetch(\n        `https://api.parasut.com/v4/${companyId}/e_archives/${eArchiveId}`,\n        { headers: { Authorization: `Bearer ${accessToken}` } }\n      );\n\n      if (response.ok) {\n        const data = await response.json() as {\n          data: { attributes: { pdf_url?: string; status?: string } };\n        };\n\n        const pdfUrl = data.data.attributes.pdf_url;\n        if (pdfUrl) {\n          console.log('Parasut: Got PDF URL');\n          return pdfUrl;\n        }\n\n        const status = data.data.attributes.status;\n        if (attempt % 5 === 0) {\n          console.log(`Parasut: E-Archive status: ${status}, attempt ${attempt + 1}/${maxAttempts}`);\n        }\n      }\n\n      // Wait before retrying\n      await new Promise(resolve => setTimeout(resolve, delayMs));\n    }\n\n    console.warn(`Parasut: PDF URL not available after ${maxAttempts} attempts`);\n    return null;\n  }\n\n  /**\n   * Get invoice print URL\n   */\n  async getInvoicePrintUrl(accessToken: string, invoiceId: string): Promise<string | null> {\n    const { companyId } = this.config;\n\n    try {\n      const response = await fetch(\n        `https://api.parasut.com/v4/${companyId}/sales_invoices/${invoiceId}`,\n        { headers: { Authorization: `Bearer ${accessToken}` } }\n      );\n\n      if (!response.ok) {\n        console.error('Failed to get invoice:', response.status);\n        return null;\n      }\n\n      const data = await response.json() as {\n        data: { attributes: { print_url?: string } };\n      };\n\n      const printUrl = data.data.attributes.print_url;\n      if (printUrl) {\n        console.log('Parasut: Got print URL');\n        return printUrl;\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error getting invoice print URL:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Main method: Create complete invoice from payment\n   */\n  async createInvoice(\n    paymentData: { merchantOid: string; totalAmount: number },\n    invoiceData: InvoiceData\n  ): Promise<InvoiceResult> {\n    try {\n      const accessToken = await this.getAccessToken();\n      const amount = paymentData.totalAmount;\n\n      // Create or find contact\n      let contactId: string;\n      if (invoiceData.invoiceType === 'company' && invoiceData.companyData) {\n        contactId = await this.createCompanyContact(accessToken, invoiceData.companyData);\n      } else {\n        contactId = await this.createMinimalContact(accessToken);\n      }\n\n      // Create sales invoice\n      const invoiceId = await this.createSalesInvoice(\n        accessToken,\n        contactId,\n        amount,\n        paymentData.merchantOid\n      );\n\n      // Record payment (non-blocking)\n      await this.recordPayment(accessToken, invoiceId, amount, paymentData.merchantOid);\n\n      // Generate e-Archive and wait for PDF URL\n      let eArchiveId: string | undefined;\n      let pdfUrl: string | null = null;\n\n      try {\n        eArchiveId = await this.generateEArchive(accessToken, invoiceId);\n        if (eArchiveId) {\n          // Poll for PDF URL with shorter timeout (Lambda has limited time)\n          // E-Archive PDF generation typically takes 30-60 seconds\n          pdfUrl = await this.getEArchivePdfUrl(accessToken, eArchiveId);\n        }\n      } catch (e) {\n        console.log('E-Archive generation failed:', e);\n      }\n\n      return {\n        success: true,\n        invoiceId,\n        eArchiveId,\n        pdfUrl: pdfUrl || undefined,\n      };\n    } catch (error) {\n      console.error('Parasut invoice creation failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n}\n\n/**\n * Register webhook with Parasut\n */\nexport async function registerParasutWebhook(\n  webhookUrl: string,\n  events: string[] = ['e_archive.created', 'e_archive.updated', 'e_invoice.created', 'e_invoice.updated']\n): Promise<{ success: boolean; webhookId?: string; error?: string }> {\n  const service = createParasutService();\n  if (!service) {\n    return { success: false, error: 'Parasut service not configured' };\n  }\n\n  try {\n    const accessToken = await service.getAccessToken();\n    const companyId = process.env.PARASUT_COMPANY_ID;\n\n    const webhookPayload = {\n      data: {\n        type: 'webhooks',\n        attributes: {\n          url: webhookUrl,\n          events: events,\n        },\n      },\n    };\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/webhooks`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(webhookPayload),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error('Parasut register webhook error:', error);\n      return { success: false, error };\n    }\n\n    const data = await response.json() as { data: { id: string } };\n    console.log('Parasut: Webhook registered:', data.data.id);\n    return { success: true, webhookId: data.data.id };\n  } catch (error) {\n    console.error('Parasut webhook registration failed:', error);\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * List registered webhooks\n */\nexport async function listParasutWebhooks(): Promise<{ success: boolean; webhooks?: Array<{ id: string; url: string; events: string[] }>; error?: string }> {\n  const service = createParasutService();\n  if (!service) {\n    return { success: false, error: 'Parasut service not configured' };\n  }\n\n  try {\n    const accessToken = await service.getAccessToken();\n    const companyId = process.env.PARASUT_COMPANY_ID;\n\n    const response = await fetch(\n      `https://api.parasut.com/v4/${companyId}/webhooks`,\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      return { success: false, error };\n    }\n\n    const data = await response.json() as {\n      data: Array<{\n        id: string;\n        attributes: { url: string; events: string[] }\n      }>\n    };\n\n    const webhooks = data.data.map(w => ({\n      id: w.id,\n      url: w.attributes.url,\n      events: w.attributes.events,\n    }));\n\n    return { success: true, webhooks };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n}\n\n/**\n * Create a Parasut service instance from environment variables\n */\nexport function createParasutService(): ParasutInvoiceService | null {\n  const clientId = process.env.PARASUT_CLIENT_ID;\n  const clientSecret = process.env.PARASUT_CLIENT_SECRET;\n  const username = process.env.PARASUT_USERNAME;\n  const password = process.env.PARASUT_PASSWORD;\n  const companyId = process.env.PARASUT_COMPANY_ID;\n\n  if (!clientId || !clientSecret || !username || !password || !companyId) {\n    console.warn('Parasut: Missing configuration, service not available');\n    return null;\n  }\n\n  return new ParasutInvoiceService({\n    clientId,\n    clientSecret,\n    username,\n    password,\n    companyId,\n  });\n}\n", "/**\n * WhatsApp Business API utilities\n * For sending messages and documents to users\n */\n\nconst WHATSAPP_PHONE_NUMBER_ID = process.env.WHATSAPP_PHONE_NUMBER_ID;\nconst WHATSAPP_ACCESS_TOKEN = process.env.WHATSAPP_ACCESS_TOKEN;\n\ninterface WhatsAppMessageResponse {\n  messaging_product: string;\n  contacts: Array<{ input: string; wa_id: string }>;\n  messages: Array<{ id: string }>;\n}\n\ninterface WhatsAppErrorResponse {\n  error: {\n    message: string;\n    type: string;\n    code: number;\n  };\n}\n\n/**\n * Send a text message via WhatsApp\n */\nexport async function sendWhatsAppMessage(to: string, message: string): Promise<boolean> {\n  if (!WHATSAPP_PHONE_NUMBER_ID || !WHATSAPP_ACCESS_TOKEN) {\n    console.warn('WhatsApp: Missing credentials, cannot send message');\n    return false;\n  }\n\n  try {\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${WHATSAPP_PHONE_NUMBER_ID}/messages`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${WHATSAPP_ACCESS_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messaging_product: 'whatsapp',\n          to,\n          type: 'text',\n          text: { body: message },\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.json() as WhatsAppErrorResponse;\n      console.error('WhatsApp send message error:', error);\n      return false;\n    }\n\n    const data = await response.json() as WhatsAppMessageResponse;\n    console.log(`WhatsApp: Message sent to ${to}, id: ${data.messages?.[0]?.id}`);\n    return true;\n  } catch (error) {\n    console.error('WhatsApp send message failed:', error);\n    return false;\n  }\n}\n\n/**\n * Send a document via WhatsApp\n * @param to - Recipient phone number\n * @param documentUrl - Public URL to the document (PDF, etc.)\n * @param caption - Optional caption for the document\n * @param filename - Filename to display\n */\nexport async function sendWhatsAppDocument(\n  to: string,\n  documentUrl: string,\n  caption: string,\n  filename: string\n): Promise<boolean> {\n  if (!WHATSAPP_PHONE_NUMBER_ID || !WHATSAPP_ACCESS_TOKEN) {\n    console.warn('WhatsApp: Missing credentials, cannot send document');\n    return false;\n  }\n\n  try {\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${WHATSAPP_PHONE_NUMBER_ID}/messages`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${WHATSAPP_ACCESS_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messaging_product: 'whatsapp',\n          to,\n          type: 'document',\n          document: {\n            link: documentUrl,\n            caption,\n            filename,\n          },\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.json() as WhatsAppErrorResponse;\n      console.error('WhatsApp send document error:', error);\n      return false;\n    }\n\n    const data = await response.json() as WhatsAppMessageResponse;\n    console.log(`WhatsApp: Document sent to ${to}, id: ${data.messages?.[0]?.id}`);\n    return true;\n  } catch (error) {\n    console.error('WhatsApp send document failed:', error);\n    return false;\n  }\n}\n\n/**\n * Send an image via WhatsApp\n * @param to - Recipient phone number\n * @param imageUrl - Public URL to the image\n * @param caption - Optional caption for the image\n */\nexport async function sendWhatsAppImage(\n  to: string,\n  imageUrl: string,\n  caption?: string\n): Promise<boolean> {\n  if (!WHATSAPP_PHONE_NUMBER_ID || !WHATSAPP_ACCESS_TOKEN) {\n    console.warn('WhatsApp: Missing credentials, cannot send image');\n    return false;\n  }\n\n  try {\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${WHATSAPP_PHONE_NUMBER_ID}/messages`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${WHATSAPP_ACCESS_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messaging_product: 'whatsapp',\n          to,\n          type: 'image',\n          image: {\n            link: imageUrl,\n            caption,\n          },\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.json() as WhatsAppErrorResponse;\n      console.error('WhatsApp send image error:', error);\n      return false;\n    }\n\n    const data = await response.json() as WhatsAppMessageResponse;\n    console.log(`WhatsApp: Image sent to ${to}, id: ${data.messages?.[0]?.id}`);\n    return true;\n  } catch (error) {\n    console.error('WhatsApp send image failed:', error);\n    return false;\n  }\n}\n\n/**\n * Send invoice notification with PDF\n */\nexport async function sendInvoiceNotification(\n  to: string,\n  pdfUrl: string,\n  merchantOid: string\n): Promise<boolean> {\n  const caption = `Faturanƒ±z hazƒ±r!\\n\\nSipari≈ü No: ${merchantOid}\\n\\nPatron Premium √ºyeliƒüiniz i√ßin te≈üekk√ºr ederiz. üôè`;\n  const filename = `fatura-${merchantOid}.pdf`;\n\n  return sendWhatsAppDocument(to, pdfUrl, caption, filename);\n}\n\n/**\n * Send payment success notification (without PDF)\n */\nexport async function sendPaymentSuccessNotification(to: string): Promise<boolean> {\n  const message = `‚úÖ √ñdemeniz ba≈üarƒ±yla alƒ±ndƒ±!\\n\\nPremium √ºyeliƒüiniz aktif edildi. Artƒ±k t√ºm telefon numaralarƒ±nƒ± g√∂rebilirsiniz.\\n\\nSorularƒ±nƒ±z i√ßin WhatsApp'tan bize ula≈üabilirsiniz: +90 533 208 9867`;\n\n  return sendWhatsAppMessage(to, message);\n}\n\n/**\n * Send invoice generation failure notification\n */\nexport async function sendInvoiceFailureNotification(to: string): Promise<boolean> {\n  const message = `‚ö†Ô∏è Faturanƒ±z ≈üu anda olu≈üturulamadƒ±.\\n\\nEndi≈üelenmeyin, √∂demeniz ba≈üarƒ±lƒ± ve premium √ºyeliƒüiniz aktif. Faturanƒ±z en kƒ±sa s√ºrede manuel olarak olu≈üturulup g√∂nderilecektir.\\n\\nSorularƒ±nƒ±z i√ßin WhatsApp'tan bize ula≈üabilirsiniz: +90 533 208 9867`;\n\n  return sendWhatsAppMessage(to, message);\n}\n\n/**\n * Send an interactive message with a CTA URL button\n * @param to - Recipient phone number\n * @param headerText - Header text (optional)\n * @param bodyText - Main message body\n * @param footerText - Footer text (optional)\n * @param buttonText - Text on the button\n * @param buttonUrl - URL to open when button is clicked\n */\nexport async function sendWhatsAppButtonMessage(\n  to: string,\n  bodyText: string,\n  buttonText: string,\n  buttonUrl: string,\n  headerText?: string,\n  footerText?: string\n): Promise<boolean> {\n  if (!WHATSAPP_PHONE_NUMBER_ID || !WHATSAPP_ACCESS_TOKEN) {\n    console.warn('WhatsApp: Missing credentials, cannot send button message');\n    return false;\n  }\n\n  try {\n    const interactive: {\n      type: string;\n      header?: { type: string; text: string };\n      body: { text: string };\n      footer?: { text: string };\n      action: {\n        name: string;\n        parameters: {\n          display_text: string;\n          url: string;\n        };\n      };\n    } = {\n      type: 'cta_url',\n      body: { text: bodyText },\n      action: {\n        name: 'cta_url',\n        parameters: {\n          display_text: buttonText,\n          url: buttonUrl,\n        },\n      },\n    };\n\n    if (headerText) {\n      interactive.header = { type: 'text', text: headerText };\n    }\n    if (footerText) {\n      interactive.footer = { text: footerText };\n    }\n\n    const response = await fetch(\n      `https://graph.facebook.com/v18.0/${WHATSAPP_PHONE_NUMBER_ID}/messages`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${WHATSAPP_ACCESS_TOKEN}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messaging_product: 'whatsapp',\n          to,\n          type: 'interactive',\n          interactive,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.json() as WhatsAppErrorResponse;\n      console.error('WhatsApp send button message error:', error);\n      return false;\n    }\n\n    const data = await response.json() as WhatsAppMessageResponse;\n    console.log(`WhatsApp: Button message sent to ${to}, id: ${data.messages?.[0]?.id}`);\n    return true;\n  } catch (error) {\n    console.error('WhatsApp send button message failed:', error);\n    return false;\n  }\n}\n"],
  "mappings": "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",
  "names": ["pdf_check_exports", "__export", "handler", "__toCommonJS", "import_client_dynamodb", "import_lib_dynamodb", "ParasutInvoiceService", "config", "response", "error", "data", "accessToken", "companyId", "searchResponse", "firstContact", "contactData", "foundContact", "companyData", "existingContact", "contactPayload", "foundCompany", "productName", "foundProduct", "productPayload", "contactId", "amount", "merchantOid", "productId", "netAmount", "invoicePayload", "invoiceId", "paymentPayload", "eArchivePayload", "eArchiveId", "maxAttempts", "delayMs", "attempt", "pdfUrl", "status", "resolve", "printUrl", "paymentData", "invoiceData", "e", "createParasutService", "clientId", "clientSecret", "username", "password", "companyId", "ParasutInvoiceService", "WHATSAPP_PHONE_NUMBER_ID", "WHATSAPP_ACCESS_TOKEN", "sendWhatsAppDocument", "to", "documentUrl", "caption", "filename", "WHATSAPP_PHONE_NUMBER_ID", "WHATSAPP_ACCESS_TOKEN", "response", "error", "data", "sendInvoiceNotification", "to", "pdfUrl", "merchantOid", "caption", "filename", "sendWhatsAppDocument", "dynamoClient", "docClient", "TABLE_NAME", "getEArchiveIdFromInvoice", "accessToken", "companyId", "invoiceId", "response", "eDocData", "error", "getPdfUrlFromEArchive", "eArchiveId", "checkPdfStatus", "trackableJobId", "parasut", "createParasutService", "jobResponse", "jobStatus", "pdfUrl", "handler", "pendingRecords", "lastEvaluatedKey", "totalScanned", "scanResult", "processed", "sent", "record", "merchantOid", "jobId", "messageSent", "sendInvoiceNotification", "createdAt", "age", "maxAge", "resolve"]
}
